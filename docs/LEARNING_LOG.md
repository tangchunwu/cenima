# 🧠 项目复盘与知识库 (Learning Log)

本文档旨在记录我们在开发过程中遇到的**新概念、技术术语**以及**功能复盘**。既是项目的知识沉淀，也是我们共同成长的见证。

---

## 📚 术语表 (Glossary)

这里记录开发中常遇到的“黑话”和缩写。

### **i18n** (Internationalization)
*   **中文意思**：国际化
*   **为什么叫 i18n？**：因为它源自英文单词 `Internationalization`，首字母 `I` 和尾字母 `n` 之间刚好有 **18** 个字母，所以简称 `i18n`。
*   **场景**：当我们的 App 需要支持多种语言（如中文+英文）时，就需要进行“国际化”改造。通常包括提取文案、适配日期货币格式等。
*   **类似词**：
    *   **l10n** (`Localization`): 本地化。指针对特定地区（如中国、美国）进行的适配（翻译、文化调整）。
    *   **a11y** (`Accessibility`): 无障碍设计。指让残障人士也能使用的设计（`A` + 11个字母 + `y`）。
    *   **k8s** (`Kubernetes`): 容器编排工具（`K` + 8个字母 + `s`）。

### **Context API** (上下文)
*   **解释**：React 提供的一种“全局传值”机制。
*   **比喻**：普通的 Props 传值像接力赛，需要一层层往下传；Context 就像广播系统，在塔顶喊一声，底下所有组件都能直接听到，不用中间人转达。
*   **本项目应用**：我们在做中英文切换时，用 `LanguageContext` 包裹了整个 App，这样任何一个按钮组件都能直接问 Context：“现在是中文还是英文？”。

### **Hardcode** (硬编码)
*   **解释**：把数据或文本直接写死在代码里。
*   **例子**：代码写 `<h1>你好</h1>` 就是硬编码；写 `<h1>{t('hello')}</h1>` 就不是。
*   **坏处**：硬编码的东西很难改，比如想换成英文，得改源代码；而非硬编码只需改配置文件。

### **Hook** (钩子)
*   **解释**：React 的一种函数写法，通常以 `use` 开头（如 `useState`, `useEffect`）。
*   **作用**：让原本“傻瓜”的函数组件拥有“记忆”和“超能力”。
*   **本项目应用**：
    *   `useLanguage()`: 我们自己写的钩子，用来获取当前语言。
    *   `useSurvey()`: 用来管理答题进度和分数的钩子。

### **Git 基础概念** (版本控制)
*   **Stage (暂存)**
    *   **比喻**：**购物车**。
    *   **解释**：你修改了10个文件，只打算提交其中的3个。你就把这3个文件 put 到“暂存区”（放入购物车）。这时候还没有下单。
    *   **命令**：`git add .` (把所有修改放入购物车)
*   **Commit (提交)**
    *   **比喻**：**下单/结账**。
    *   **解释**：把购物车里的东西打包生成一个“订单”，并生成一个订单号（版本号）。一旦提交，就形成了一个永久的历史节点。
    *   **命令**：`git commit -m "备注"` (下单并写备注)
*   **Branch (分支)**
    *   **比喻**：**平行宇宙**。
    *   **解释**：主分支 (`main`) 是现实世界。你想试着改改代码，但怕把现实世界搞崩，就开辟一个平行宇宙 (`feature/xxx`)。你在平行宇宙里怎么折腾都不会影响现实世界。
*   **Merge (合并)**
    *   **比喻**：**宇宙融合**。
    *   **解释**：你在平行宇宙里把功能做好了，测试没问题了，就可以把这个宇宙的变动“合并”回现实世界。
    *   **命令**：`git merge`
*   **Push (推送)**
    *   **比喻**：**发朋友圈/云同步**。
    *   **解释**：你在本地P好了图（Commit），也整理好了相册（Merge）。现在点击“发布”，把这些内容真正**上传**到云端（GitHub）。在 Push 之前，这只是你手机里的私密照片；Push 之后，大家都能看到了。
    *   **命令**：`git push`

---

## 📝 迭代复盘 (Retrospective)

记录每次重大功能更新后的反思与总结。

### 🔄 2026-01-27：全站中英文切换功能

#### **1. 需求背景**
用户希望应用更加国际化，支持一键切换中英文。

#### **2. 技术方案选择**
*   **方案 A (弃用)**: 使用 `react-i18next` 等成熟库。
    *   *缺点*：库太大，配置复杂，对于目前的轻量级项目有点“杀鸡用牛刀”。
*   **方案 B (采用)**: **手写轻量级 Context + JSON 字典**。
    *   *优点*：代码量仅几十行，完全可控，理解成本低。
    *   *实现*：创建一个 `translations.ts` 文件存放所有中英文对照，用 Context 分发当前语言状态。

#### **3. 遇到的挑战**
*   **硬编码清理**：这是最累的一步。我们需要把首页、报告页所有散落在 JSX 里的中文（如“12道题”、“绝密档案”）一个个抠出来，换成变量。
    > **💡 经验教训**：如果在项目刚开始写代码时，就先把文案抽离到单独的文件里（即使当时只有中文），后期做国际化会快10倍。这叫“防患于未然”。

#### **4. 代码示例**
**改造前 (Hardcode):**
```tsx
<button>开始游戏</button>
```

**改造后 (i18n):**
```tsx
const { t } = useLanguage();
<button>{t('game.start')}</button>
```

---

### 🐛 2026-01-27：Tailwind 动态类名失效 Bug

#### **1. 现象**
用户反馈“只有金钱属性条在动，其他属性条不动”。
实际上属性值在变化，但对应的属性条背景色丢失（透明），导致视觉上看起来没动。

#### **2. 原因分析**
代码中使用了字符串拼接来生成动态类名，例如：
```tsx
// ❌ 错误写法：Tailwind 编译器无法识别
<div className={`h-full ${color.replace('text-', 'bg-')}`} />
```
Tailwind 使用 Purge/Tree-Shaking 机制，在编译时扫描代码文件。如果它在文件中找不到完整的类名（如 `bg-orange-400`），就不会将该类的 CSS 打包进去。
因为我们是通过 JS 运行时计算出 `bg-orange-400` 的，编译器在构建时根本看不到这个字符串，所以该样式被丢弃了。
*   *特例*：金钱条能显示，是因为 `bg-yellow-400` 恰好在其他文件中被完整引用过，所以被保留了。

#### **3. 解决方案**
拒绝运行时拼凑，直接传递完整的类名字符串：
```tsx
// ✅ 正确写法：显式传递完整类名
<AttributeBar barColor="bg-orange-400" ... />
```
这样 Tailwind 编译器就能扫描到 `bg-orange-400` 并将其包含在最终的 CSS 文件中。

> **💡 经验教训**：在使用 Utility-First CSS（如 Tailwind）时，**永远不要动态拼接类名**，除非你使用了 safelist 配置。所见即所得。

---

> **💡 经验教训**：在使用 Utility-First CSS（如 Tailwind）时，**永远不要动态拼接类名**，除非你使用了 safelist 配置。所见即所得。

### 📦 资源引用 (Assets)
用户问：*“Unsplash 也可以直接导进来吗？”*
这里涉及两种常见的资源使用方式：

#### **1. 远程引用 (Remote/CDN)**
*   **做法**：直接在代码里写图片的 **网址 (URL)**。
    ```tsx
    // 就像可以在浏览器打开这个链接一样，代码也能直接读取
    const image = "https://images.unsplash.com/photo-xxx...";
    <img src={image} />
    ```
*   **优点**：不需要下载图片到电脑，不占项目体积，即插即用。
*   **缺点**：如果对方网站挂了，图就裂了；而且需要联网。
*   **本次案例**：我们直接使用了 Unsplash 提供的图片链接，就像“借”用了他们的图，而没有把图“搬”回家。

#### **2. 本地引用 (Local)**
*   **做法**：把图片下载下来，放在 `src/assets` 文件夹里，然后 `import` 进来。
*   **优点**：稳定，断网也能看。
*   **缺点**：项目文件会变大。

---

### 🎨 2026-01-29：使用 shadcn CLI 安装第三方组件

#### **1. 需求背景**
想给网站添加一个炫酷的鼠标跟随水花特效 (SplashCursor)，提升用户体验和视觉感受。

#### **2. 技术发现**
原来 `shadcn` 不仅可以安装官方组件，还可以安装第三方社区组件！

*   **官方组件**：如 `button`, `card`, `dialog` 等
*   **第三方组件**：如 `@react-bits/SplashCursor-JS-CSS`

#### **3. 安装步骤**
```bash
# 使用 shadcn CLI 安装第三方组件
npx shadcn@latest add @react-bits/SplashCursor-JS-CSS
```

执行后，组件会被自动下载到 `src/components/` 目录下。

#### **4. 使用方法**
```tsx
// 在 App.tsx 或全局布局组件中导入
import SplashCursor from '@/components/SplashCursor'

// 在 JSX 中使用（放在根组件即可全局生效）
<SplashCursor />
```

#### **5. shadcn 的本质**
> **💡 关键认知**：`shadcn` **不是一个 npm 包**，而是一个**代码复制工具 (Code CLI)**。
>
> 它不像 `antd` 或 `mui` 那样把组件打包成 node_modules 依赖，而是把组件的**源代码直接复制**到你的项目里。
>
> *   **优点**：你拥有组件的完整源码，可以随意修改样式和逻辑。
> *   **缺点**：不会自动更新，如果官方修了 bug，你需要手动更新。

#### **6. @react-bits 是什么？**
`@react-bits` 是一个开源的 React 组件库集合，专门提供各种**视觉特效组件**，比如：
*   `SplashCursor`：鼠标水花特效
*   `Aurora`：极光背景
*   `Particles`：粒子效果
*   等等...

这些组件都可以通过 shadcn CLI 一键安装。

> **💡 经验教训**：当你想要某个 UI 特效时，先去搜搜有没有现成的 shadcn 兼容组件，很可能一行命令就搞定了，不用自己从头写！

#### **7. 实际应用：卡片堆叠翻转效果**
在游戏模式的 LifeEditor 组件中，我们实现了卡片堆叠翻转效果：

```tsx
// 1. 堆叠的卡片背景 - 通过绝对定位和 scale/translateY 创建层次感
{[...Array(Math.min(3, remainingCards))].map((_, i) => (
  <motion.div
    style={{ 
      zIndex: -i - 1,
      scale: 1 - (i + 1) * 0.03,
      y: -(i + 1) * 8,
      rotateX: (i + 1) * 2
    }}
  />
))}

// 2. 当前卡片翻转动画 - 使用 rotateY 实现3D翻转
<motion.div
  initial={{ rotateY: 90, opacity: 0 }}
  animate={{ rotateY: 0, opacity: 1 }}
  exit={{ rotateY: -90, opacity: 0 }}
  style={{ transformStyle: 'preserve-3d' }}
/>
```

**关键技术点**：
*   `perspective: 1000px`：给父容器添加透视，让子元素的3D变换有立体感
*   `transformStyle: 'preserve-3d'`：保持3D变换效果
*   `rotateY`：水平翻转动画
*   `rotateY`：水平翻转动画
*   `rotateX`：轻微倾斜，模拟卡片堆叠的视角

#### **8. CSS 排板：长链接溢出处理**
在分享卡片中，由于自动生成的 URL 包含大量参数变得非常长，导致在移动端撑破了容器宽度。
*   **问题**：默认的 `whitespace-pre-line` 只处理换行符，不处理长单词（URL被视为一个长单词）。
*   **修复**：添加 `break-all` 类（或 `word-break: break-all`）。
    ```html
    <p className="break-all">...</p>
    ```
    这样可以强制长链接在任意字符处换行，防止布局破坏。

#### **9. 视觉优化：图表升级**
在 `HealthScoreCard` 中，我们将简单的进度条升级为雷达图 (`DimensionRadarChart`)。
*   **优势**：雷达图能更直观地展示多维数据的平衡性，且科技感更强。
*   **实现**：使用 `recharts` 库，配合 `ResponsiveContainer` 确保自适应。
*   **布局**：将雷达图作为视觉中心，原有进度条作为详细数据补充，形成“总-分”结构。

#### **10. 交互升级：Reigns 式滑动决策**
为了增强游戏趣味性，我们将简单的点击交互升级为 Tinder/Reigns 风格的卡片滑动决策。
*   **挑战**：如何精确控制拖拽手感，避免误触。
*   **方案**：使用 `framer-motion` 的 `useMotionValue` 和 `useTransform`。
    *   `x` 位移驱动 `rotate` (旋转) 和 `opacity` (透明度) 变化。
    *   `drag="x"` 限制水平拖动。
    *   通过 `dragConstraints` 和 `onDragEnd` 判断滑动意图。
    ```tsx
    const x = useMotionValue(0);
    const rotate = useTransform(x, [-200, 200], [-30, 30]); 
    // ...
    <motion.div drag="x" style={{ x, rotate }}>
    ```
*   **收获**：物理模拟的交互能显著提升沉浸感，比纯粹的 CSS 动画更生动。

---

*文档持续更新中...*
